//-----------------------------------------------------------------------------
// Entaro ChucK Developer!
// This is a Chugin boilerplate, generated by chugerate!
//-----------------------------------------------------------------------------

// this should align with the correct versions of these ChucK files
#include "chuck_dl.h"
#include "chuck_def.h"

// general includes
#include <stdio.h>
#include <limits.h>
#include <vector>
#include <stdio.h>
#include <algorithm>

CK_DLL_CTOR(sort_ctor);
CK_DLL_DTOR(sort_dtor);

CK_DLL_MFUN(sort_setFreq);
CK_DLL_MFUN(sort_getFreq);
CK_DLL_MFUN(sort_setSize);
CK_DLL_MFUN(sort_getSize);
CK_DLL_MFUN(sort_setInterpolation);
CK_DLL_MFUN(sort_getInterpolation);
CK_DLL_MFUN(sort_getIteration);
CK_DLL_MFUN(sort_getPosition);

CK_DLL_MFUN(sort_setInsert);
CK_DLL_MFUN(sort_setSelection);
CK_DLL_MFUN(sort_setBubble);

// for Chugins extending UGen, this is mono synthesis function for 1 sample
CK_DLL_TICK(sort_tick);
// this is a special offset reserved for Chugin internal data
t_CKINT sort_data_offset = 0;

using namespace std;


void insertSort(vector<float> & arr, int n, int step) {
    int i = step + 1;

    float value = arr[i];
    int j = i;

    while (j > 0 && arr[j - 1] > value) {
        arr[j] = arr[j - 1];
        j--;
    }

    arr[j] = value;
}

void selectionSort(vector<float> & arr, int n, int step) {
    int i = step;

    int min = i;
    for (int j = i + 1; j < n; j++) {
        if (arr[j] < arr[min]) {
            min = j;
        }
    }

    swap(arr[min], arr[i]);
}

void bubbleSort(vector<float> & arr, int n, int step) {
    int i = step;

    for (int j = 0; j < n - 1 - i; j++) {
        if (arr[j] > arr[j + 1]) {
            swap(arr[j], arr[j + 1]);
        }
    }
}

bool isSorted(vector<float> & arr, int m_size) {
    bool sorted = true;
    for (int i = 0; i < m_size - 1; i++) {
        if (arr[i] > arr[i + 1]) {
            sorted = false;
            break;
        }
    }
    return sorted;
}

class Sort
{
public:
    Sort( t_CKFLOAT fs)
    {
        m_size = 0;
        m_freq = 0;
        m_fs = fs;
        m_iteration = 0;
        m_interpolation = 0;

        setFreq(440.0);

        m_sortingType = INSERT;
    }

    float setFreq( t_CKFLOAT f ) {
        m_freq = f;
        setSize(int(m_fs/m_freq));

        return m_freq;
    }

    float getFreq() {
        return m_freq;
    }

    int setInterpolation( t_CKINT i ) {
        m_interpolation = i;
        return m_interpolation;
    }

    int getInterpolation() {
        return m_interpolation;
    }

    int setSize( t_CKINT s ) {
        m_size = s;

        m_samples.resize(m_size);
        m_copy.resize(m_size);

        randomizeSamples();

        return m_size;
    }

    int getSize() {
        return m_size;
    }

    float getPosition() {
        return m_position;
    }

    void randomizeSamples() {
        for (int i = 0; i < m_size; i++) {
            m_samples[i] = ((double) rand() / RAND_MAX) * 2.0 - 1.0;
            m_copy[i] = m_samples[i];
        }
    }

    void sort() {
        // for (int i = 0; i < m_size; i++) {
        // }

        switch(m_sortingType) {

        case INSERT:
            insertSort(m_copy, m_size, m_iteration);
            break;
        case SELECTION:
            selectionSort(m_copy, m_size, m_iteration);
            break;
        case BUBBLE:
            bubbleSort(m_copy, m_size, m_iteration);
            break;
        case MERGE:
            // mergeSort(m_samples, m_size, m_iteration);
            break;
        case QUICK:
            // quickSort(m_samples, m_size, m_iteration);
            break;
        case HEAP:
            // heapSort(m_samples, m_size, m_iteration);
            break;
        default:
            break;
        }
    }

    void setInsert() {
        m_sortingType = INSERT;
    }

    void setSelection() {
        m_sortingType = SELECTION;
    }

    void setBubble() {
        m_sortingType = BUBBLE;
    }

    int getIteration() {
        return m_iteration;
    }

    SAMPLE tick( SAMPLE in )
    {
        m_position++;
        m_position = m_position % m_size;

        if (m_position == 0) {
            sort();
            if (isSorted(m_copy, m_size)) {
                randomizeSamples();
                m_iteration = 0;
            } else {
                m_iteration++;
            }

        }

        return m_copy[m_position];
    }


private:
    float m_freq;
    float m_fs;
    int m_size;
    int m_position;
    int m_iteration;
    int m_interpolation;

    vector<float> m_samples;
    vector<float> m_copy;

    enum SortingTypes {
        INSERT = 0,
        SELECTION,
        BUBBLE,
        MERGE,
        QUICK,
        HEAP
    };

    SortingTypes m_sortingType;
};


// query function: chuck calls this when loading the Chugin
// NOTE: developer will need to modify this function to
// add additional functions to this Chugin
CK_DLL_QUERY( Sort )
{
    // hmm, don't change this...
    QUERY->setname(QUERY, "Sort");

    // begin the class definition
    // can change the second argument to extend a different ChucK class
    QUERY->begin_class(QUERY, "Sort", "UGen");

    // register the constructor/deconstructor (probably no need to change)
    QUERY->add_ctor(QUERY, sort_ctor);
    QUERY->add_dtor(QUERY, sort_dtor);

    // for UGen's only: add tick function
    QUERY->add_ugen_func(QUERY, sort_tick, NULL, 1, 1);

    // NOTE: if this is to be a UGen with more than 1 channel,
    // e.g., a multichannel UGen -- will need to use add_ugen_funcf()
    // and declare a tickf function using CK_DLL_TICKF

    QUERY->add_mfun(QUERY, sort_setFreq, "float", "freq");
    QUERY->add_arg(QUERY, "float", "arg");

    QUERY->add_mfun(QUERY, sort_getFreq, "float", "freq");

    QUERY->add_mfun(QUERY, sort_setInterpolation, "int", "interpolation");
    QUERY->add_arg(QUERY, "int", "arg");

    QUERY->add_mfun(QUERY, sort_getInterpolation, "int", "interpolation");

    QUERY->add_mfun(QUERY, sort_getIteration, "int", "iteration");

    QUERY->add_mfun(QUERY, sort_getPosition, "int", "position");

    QUERY->add_mfun(QUERY, sort_setSize, "int", "size");
    QUERY->add_arg(QUERY, "int", "arg");

    QUERY->add_mfun(QUERY, sort_getSize, "int", "size");

    QUERY->add_mfun(QUERY, sort_setInsert, "void", "setInsert");
    QUERY->add_mfun(QUERY, sort_setSelection, "void", "setSelection");
    QUERY->add_mfun(QUERY, sort_setBubble, "void", "setBubble");

    // this reserves a variable in the ChucK internal class to store
    // referene to the c++ class we defined above
    sort_data_offset = QUERY->add_mvar(QUERY, "int", "@s_data", false);

    // end the class definition
    // IMPORTANT: this MUST be called!
    QUERY->end_class(QUERY);

    // wasn't that a breeze?
    return TRUE;
}


// implementation for the constructor
CK_DLL_CTOR(sort_ctor)
{
    // get the offset where we'll store our internal c++ class pointer
    OBJ_MEMBER_INT(SELF, sort_data_offset) = 0;

    // instantiate our internal c++ class representation
    Sort * s_obj = new Sort(API->vm->get_srate());

    // store the pointer in the ChucK object member
    OBJ_MEMBER_INT(SELF, sort_data_offset) = (t_CKINT) s_obj;
}


// implementation for the destructor
CK_DLL_DTOR(sort_dtor)
{
    // get our c++ class pointer
    Sort * s_obj = (Sort *) OBJ_MEMBER_INT(SELF, sort_data_offset);
    // check it
    if( s_obj )
    {
        // clean up
        delete s_obj;
        OBJ_MEMBER_INT(SELF, sort_data_offset) = 0;
        s_obj = NULL;
    }
}


// implementation for tick function
CK_DLL_TICK(sort_tick)
{
    // get our c++ class pointer
    Sort * s_obj = (Sort *) OBJ_MEMBER_INT(SELF, sort_data_offset);

    // invoke our tick function; store in the magical out variable
    if(s_obj) *out = s_obj->tick(in);

    // yes
    return TRUE;
}

CK_DLL_MFUN(sort_setFreq)
{
    Sort * s_obj = (Sort *) OBJ_MEMBER_INT(SELF, sort_data_offset);
    RETURN->v_float = s_obj->setFreq(GET_NEXT_FLOAT(ARGS));
}


CK_DLL_MFUN(sort_getFreq)
{
    Sort * s_obj = (Sort *) OBJ_MEMBER_INT(SELF, sort_data_offset);
    RETURN->v_float = s_obj->getFreq();
}

CK_DLL_MFUN(sort_setSize)
{
    Sort * s_obj = (Sort *) OBJ_MEMBER_INT(SELF, sort_data_offset);
    RETURN->v_int = s_obj->setSize(GET_NEXT_INT(ARGS));
}

CK_DLL_MFUN(sort_getSize)
{
    Sort * s_obj = (Sort *) OBJ_MEMBER_INT(SELF, sort_data_offset);
    RETURN->v_int= s_obj->getSize();
}

CK_DLL_MFUN(sort_setInterpolation)
{
    Sort * s_obj = (Sort *) OBJ_MEMBER_INT(SELF, sort_data_offset);
    RETURN->v_int = s_obj->setInterpolation(GET_NEXT_INT(ARGS));
}

CK_DLL_MFUN(sort_getInterpolation)
{
    Sort * s_obj = (Sort *) OBJ_MEMBER_INT(SELF, sort_data_offset);
    RETURN->v_int = s_obj->getInterpolation();
}

CK_DLL_MFUN(sort_getIteration)
{
    Sort * s_obj = (Sort *) OBJ_MEMBER_INT(SELF, sort_data_offset);
    RETURN->v_int = s_obj->getIteration();
}

CK_DLL_MFUN(sort_getPosition)
{
    Sort * s_obj = (Sort *) OBJ_MEMBER_INT(SELF, sort_data_offset);
    RETURN->v_int = s_obj->getPosition();
}

CK_DLL_MFUN(sort_setInsert)
{
    Sort * s_obj = (Sort *) OBJ_MEMBER_INT(SELF, sort_data_offset);
    s_obj->setInsert();
}

CK_DLL_MFUN(sort_setSelection)
{
    Sort * s_obj = (Sort *) OBJ_MEMBER_INT(SELF, sort_data_offset);
    s_obj->setSelection();
}

CK_DLL_MFUN(sort_setBubble)
{
    Sort * s_obj = (Sort *) OBJ_MEMBER_INT(SELF, sort_data_offset);
    s_obj->setBubble();
}
